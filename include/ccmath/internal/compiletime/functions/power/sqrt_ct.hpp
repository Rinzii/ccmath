/*
 * Copyright (c) 2024-Present Ian Pike
 * Copyright (c) 2024-Present ccmath contributors
 *
 * This library is provided under the MIT License.
 * See LICENSE for more information.
 */

#pragma once

#include "ccmath/internal/config/type_support.hpp"
#include "ccmath/internal/predef/unlikely.hpp"
#include "ccmath/internal/support/always_false.hpp"
#include "ccmath/internal/support/bits.hpp"
#include "ccmath/internal/support/fenv/rounding_mode.hpp"
#include "ccmath/internal/support/fp/fp_bits.hpp"
#include "ccmath/internal/support/is_constant_evaluated.hpp"

#include <type_traits>

namespace ccm::ct
{
	namespace internal
	{
		template <typename T>
		static constexpr std::array<T, 256> lut_double_sqrt_first_256 = {
			0, 1, 1.41421356237309504876378807303183294, 1.73205080756887729357372529559455643, 2, 2.23606797749978969641442005933384962, 2.44948974278317809817606676148216138, 2.64575131106459059040364456549809802, 2.82842712474619009752757614606366587, 3, 3.16227766016837933196748089414995775, 3.31662479035539984901365118119542785, 3.46410161513775458714745059118911286, 3.60555127546398929312687631210110339, 3.74165738677394138565583669997494098, 3.87298334620741688521378121023985841, 4, 4.12310562561766054965120553710278273, 4.24264068711928514629136421909549881, 4.35889894354067355215429091508383408, 4.47213595499957939282884011866769924, 4.58257569495584000680149516782080354, 4.69041575982342955454876265442010208, 4.79583152331271954154842673823111454, 4.89897948556635619635213352296432276, 5, 5.09901951359278482987791303315816549, 5.1961524227066318805043354522865684, 5.29150262212918118080728913099619604, 5.38516480713450403127254273449864286, 5.4772255750516611345207751426755749, 5.56776436283002192214816594706405795, 5.65685424949238019505515229212733175, 5.74456264653802865967346935605064573, 5.83095189484530047104721139916705397, 5.91607978309961604276856483863866742, 6, 6.08276253029821968891163730397408926, 6.16441400296897645035704149663047247, 6.24499799839839820573411666160268396, 6.3245553203367586639349617882999155, 6.40312423743284868642849927411475619, 6.48074069840786023098677670617462354, 6.55743852430200065226767458526069277, 6.63324958071079969802730236239085571, 6.70820393249936908902641974350444798, 6.78232998312526813924905333408332808, 6.85565460040104412498332409064971671, 6.92820323027550917429490118237822571, 7, 7.07106781186547524381894036515916468, 7.14142842854284999815420165170110067, 7.21110255092797858625375262420220679, 7.28010988928051827129631079493776724, 7.34846922834953429452820028444648415, 7.41619848709566294869821589941238926, 7.48331477354788277131167339994988197, 7.54983443527074969724502406798194443, 7.61577310586390828547193043718266381, 7.68114574786860817559239200669196634, 7.74596669241483377042756242047971682, 7.81024967590665439428829208701188236, 7.87400787401181101975156106931308386, 7.93725393319377177164461456548849583, 8, 8.06225774829854965278924661120640849, 8.12403840463596036043647519164778714, 8.18535277187244997027654180854483457, 8.24621125123532109930241107420556546, 8.3066238629180748527514044354802536, 8.36660026534075548006880174156663088, 8.42614977317635863076489277645464426, 8.48528137423857029258272843819099762, 8.54400374531753116751769949743788857, 8.60232526704262677203632891931306403, 8.66025403784438646721810517448147948, 8.71779788708134710430858183016766816, 8.77496438739212206072565214398650824, 8.83176086632784685444969019485483841, 8.88819441731558885014252702205794776, 8.94427190999915878565768023733539849, 9, 9.05538513813741662624584582985676207, 9.11043357914429888233520671292353654, 9.16515138991168001360299033564160709, 9.21954445729288731004036350213937112, 9.27361849549570375211837713891327439, 9.32737905308881504531925976664297195, 9.38083151964685910909752530884020416, 9.43398113205660381139910919401359024, 9.48683298050513799590244268244987325, 9.53939201416945649174283783366945499, 9.59166304662543908309685347646222908, 9.64365076099295499573865741993472511, 9.69535971483265802788042986293248759, 9.7467943448089639068426803802935865, 9.79795897113271239270426704592864553, 9.8488578017961047215630965290245058, 9.89949493661166534178019738021703233, 9.94987437106619954704095354358628356, 10, 10.0498756211208902702075596025110826, 10.0995049383620779529305289123897182, 10.1488915650922194690644606573926012, 10.198039027185569659755826066316331, 10.2469507659595983834269206091960314, 10.2956301409870003161356466492293293, 10.3440804327886004699427191511063029, 10.3923048454132637610086709045731368, 10.4403065089105501796196140418260256, 10.4880884817015154700931001130470577, 10.5356537528527388486443427950689511, 10.5830052442583623616145782619923921, 10.6301458127346494077561378510665691, 10.6770782520313112107929187644117519, 10.723805294763608305166902034955001, 10.7703296142690080625450854689972857, 10.8166538263919678793806289363033102, 10.8627804912002157242817412807767141, 10.9087121146357144112898351906437711, 10.9544511501033222690415502853511498, 11, 11.0453610171872607745996441863667314, 11.0905365064094171617323225653706231, 11.1355287256600438442963318941281159, 11.180339887498948482288940731166349, 11.2249721603218241567506696654277221, 11.2694276695846448826943131393818476, 11.3137084989847603901103045842546635, 11.357816691600547221417671917009784, 11.4017542509913797910137134294927819, 11.4455231422595970387778852028759502, 11.4891252930760573193469387121012915, 11.5325625946707958895814938315993459, 11.5758369027902254739040288633589171, 11.6189500386222506556413436307195752, 11.6619037896906009420944227983341079, 11.7046999107196251091803085309095422, 11.7473401244707305870682012560735075, 11.7898261225515959688125988691353996, 11.8321595661992320855371296772773348, 11.8743420870379172349026730692855836, 11.9163752878129849538391127339309605, 11.9582607431013980209613678518110191, 12, 12.0415945787922954801976715977218646, 12.0830459735945720681563053666707219, 12.1243556529821410547992366346647941, 12.1655250605964393778232746079481785, 12.2065556157337029522663707226115548, 12.2474487139158904908803338074108069, 12.2882057274445075914157121665937211, 12.3288280059379529007140829932609449, 12.36931687685298164938729748030255, 12.4096736459908565958915049876054582, 12.4498995979887323746690408476922585, 12.4899959967967964114682333232053679, 12.5299640861416677886305826028490173, 12.5698050899765347157913120135219742, 12.609520212918491531561837604158427, 12.649110640673517327869923576599831, 12.6885775404495203802154867922524772, 12.7279220613578554393077735262806982, 12.7671453348037046617718948127162548, 12.8062484748656973728569985482295124, 12.8452325786651290204579134446305488, 12.8840987267251254949282368578167279, 12.9228479833200854687280667576487758, 12.9614813968157204619735534123492471, 13, 13.0384048104052974294611577654734447, 13.076696830622020656896553614245704, 13.1148770486040013045353491705213855, 13.1529464379659054400206752433177826, 13.190905958272919171365977764054378, 13.2287565553229529528855845654788936, 13.2664991614215993960546047247817114, 13.3041346956500707247178505454598962, 13.3416640641263337125482779654817023, 13.3790881602596520147038794412708285, 13.416407864998738178052839487008896, 13.4536240470737103172224613523155767, 13.4907375632320414658021912046592661, 13.5277492584686828977838524146193322, 13.5646599662505362784981066681666562, 13.6014705087354433451704571744755867, 13.6381816969858558931394387769842069, 13.6747943311773431582234472614345577, 13.7113092008020882499666481812994334, 13.7477270848675200195371237654740071, 13.7840487520902217682614021576625873, 13.820274961085253314328757934248415, 13.8564064605510183485898023647564514, 13.892443989449804508766461719204699, 13.9283882771841193383074997136361617, 13.9642400437689411700839525742878777, 14, 14.0356688476181996304281707210748209, 14.071247279470288664079968832254508, 14.1067359796658844256489473423243908, 14.1421356237309504876378807303183294, 14.17744687875782520335848913006771, 14.2126704035518954972322491769887165, 14.2478068487750071692554687530218871, 14.2828568570856999963084033034022013, 14.3178210632763531547778645958146626, 14.3527000944073237472323190111467284, 14.3874945699381586250789610836875454, 14.4222051018559571725075052484044136, 14.4568322948009603031577219311998306, 14.4913767461894385738668811214324705, 14.5258390463339500681821947480898416, 14.5602197785610365425926215898755345, 14.5945195193264241973266082119664588, 14.62873883832779345684493854662378, 14.6628782986151801450216969335826889, 14.6969384566990685890564005688929683, 14.7309198626562353586291753693160445, 14.7648230602334005756581802870641695, 14.7986485869487420568776925300369385, 14.8323969741913258973964317988247785, 14.8660687473185055221952532988893836, 14.8996644257513397189771064965668756, 14.9331845230680786626442646536361281, 14.9666295470957655426233467998997639, 15, 15.0332963783729082708415236702137463, 15.0665191733193636154305994345747877, 15.0996688705414993944900481359638889, 15.1327459504215559270290381022050497, 15.1657508881031011082479720286642078, 15.1986841535706636314301265500148475, 15.2315462117278165709438608743653276, 15.2643375224737480252978905070904148, 15.2970585407783544905011008374629, 15.3297097167558916564616966482503813, 15.3622914957372163511847840133839327, 15.3948043183406524259809744492599748, 15.4272486205415124893222666990766356, 15.4596248337403065200787444233299084, 15.4919333848296675408551248409594336, 15.5241746962600237289692239883720504, 15.5563491861040455368353496723443641, 15.5884572681198956415130063568597052, 15.6204993518133087885765841740237647, 15.6524758424985278746840999808398465, 15.6843871413581219340788175387046977, 15.7162336455017109804188635280297603, 15.7480157480236220395031221386261677, 15.7797338380595000449299614153630955, 15.8113883008418966598374044707497887, 15.8429795177548594850569507741511188, 15.8745078663875435432892291309769917, 15.9059737205868663538488316788743759, 15.9373774505092273669551450332448894, 15.9687194226713119991900580174615243,
		};

		template <typename T>
		struct Is80BitLongDouble
		{
			static constexpr bool value = false;
		};

		template <typename T>
		constexpr void normalize(int & exponent, typename support::FPBits<T>::storage_type & mantissa)
		{
			const int shift = support::countl_zero(mantissa) - (8 * static_cast<int>(sizeof(mantissa)) - 1 - support::FPBits<T>::fraction_length);
			exponent -= shift;
			mantissa <<= shift;
		}

#if defined(CCM_TYPES_LONG_DOUBLE_IS_FLOAT80)
		template <>
		struct Is80BitLongDouble<long double>
		{
			static constexpr bool value = true;
		};
#endif

#if defined(CCM_TYPES_LONG_DOUBLE_IS_FLOAT64)
		template <>
		constexpr void normalize<long double>(int & exponent, std::uint64_t & mantissa)
		{
			normalize<double>(exponent, mantissa);
		}
#elif defined(CCM_TYPES_LONG_DOUBLE_IS_FLOAT80)
		template <>
		constexpr void normalize<long double>(int & exponent, types::uint128_t & mantissa)
		{
			const auto shift = static_cast<unsigned int>(static_cast<unsigned long>(support::countl_zero(static_cast<std::uint64_t>(mantissa))) -
														 (8 * sizeof(std::uint64_t) - 1 - support::FPBits<long double>::fraction_length));
			exponent -= shift; // NOLINT(cppcoreguidelines-narrowing-conversions, bugprone-narrowing-conversions)
			mantissa <<= shift;
		}
#endif

		template <typename T>
		constexpr bool Is80BitLongDouble_v = Is80BitLongDouble<T>::value;

		namespace impl
		{
			namespace bit80
			{
				// This has to be defined for sqrt_impl to work as it still needs to see that this function exists
				constexpr long double sqrt_calc_80bits(long double x);

#if defined(CCM_TYPES_LONG_DOUBLE_IS_FLOAT80)
				constexpr long double sqrt_calc_80bits(long double x)
				{
					using Bits				   = support::FPBits<long double>;
					using storage_type		   = typename Bits::storage_type;
					constexpr storage_type one = static_cast<storage_type>(1) << Bits::fraction_length;
					constexpr auto nan_type	   = Bits::quiet_nan().get_val();

					Bits const bits(x);

					if (bits == Bits::inf(types::Sign::POS) || bits.is_zero() || bits.is_nan()) { return x; }
					if (bits.is_neg()) { return nan_type; }

					int x_exp			= bits.get_explicit_exponent();
					storage_type x_mant = bits.get_mantissa();

					// If we have denormal values, normalize it.
					if (bits.get_implicit_bit()) { x_mant |= one; }
					else if (bits.is_subnormal()) { normalize<long double>(x_exp, x_mant); }

					// Ensure that the exponent is even.
					if ((x_exp & 1) != 0)
					{
						--x_exp;
						x_mant <<= 1;
					}

					storage_type y = one;
					storage_type r = x_mant - one;

					for (storage_type current_bit = one >> 1; current_bit != 0U; current_bit >>= 1)
					{
						r <<= 1;
						if (const storage_type tmp = (y << 1) + current_bit; r >= tmp)
						{
							r -= tmp;
							y += current_bit;
						}
					}

					// We perform one more iteration to ensure that the result is correctly rounded.
					const auto lsb = static_cast<bool>(y & 1);
					bool round_bit = false;
					r <<= 2;
					if (const storage_type tmp = (y << 2) + 1; r >= tmp)
					{
						r -= tmp;
						round_bit = true;
					}

					// Append the exponent field.
					x_exp = ((x_exp >> 1) + Bits::exponent_bias);
					y |= (static_cast<storage_type>(x_exp) << (Bits::fraction_length + 1));

					switch (support::fenv::get_rounding_mode())
					{
					case FE_TONEAREST:
						// Round to nearest, ties to even
						if (round_bit && (lsb || (r != 0))) { ++y; }
						break;
					case FE_UPWARD:
						if (round_bit || (r != 0)) { ++y; }
						break;
					default: break;
					}

					// Extract output
					support::FPBits<long double> out(0.0L);
					out.set_biased_exponent(static_cast<storage_type>(x_exp));
					out.set_implicit_bit(true);
					out.set_mantissa(y & (one - 1));

					return out.get_val();
				}
#endif
			} // namespace bit80

			template <typename T>
			static constexpr std::enable_if_t<std::is_floating_point_v<T>, T> sqrt_calc_bits(const support::FPBits<T> & bits)
			{
				using FPBits_t			   = support::FPBits<T>;
				using storage_type		   = typename FPBits_t::storage_type;
				constexpr storage_type one = storage_type(1) << FPBits_t::fraction_length;

				int x_exp			= bits.get_exponent();
				storage_type x_mant = bits.get_mantissa();

				// If we have denormal values, normalize it.
				if (bits.is_subnormal())
				{
					++x_exp; // ensure that x_exp is the correct exponent of one bit.
					internal::normalize<T>(x_exp, x_mant);
				}
				else { x_mant |= one; }

				// Ensure that the exponent is even.
				if (x_exp & 1)
				{
					--x_exp;
					x_mant <<= 1;
				}

				storage_type y = one;
				storage_type r = x_mant - one;

				for (storage_type current_bit = one >> 1; current_bit; current_bit >>= 1)
				{
					r <<= 1;
					storage_type const tmp = (y << 1) + current_bit; // 2*y(n - 1) + 2^(-n-1)
					if (r >= tmp)
					{
						r -= tmp;
						y += current_bit;
					}
				}

				// We perform one more iteration to ensure that the result is correctly rounded.
				auto lsb	   = static_cast<bool>(y & 1); // Least significant bit
				bool round_bit = false;

				r <<= 2;

				if (storage_type const tmp = (y << 2) + 1; r >= tmp)
				{
					r -= tmp;
					round_bit = true;
				}

				// Remove the hidden bit and append the exponent field.
				x_exp = ((x_exp >> 1) + FPBits_t::exponent_bias);

				y = (y - one) | (static_cast<storage_type>(x_exp) << FPBits_t::fraction_length);

				switch (support::fenv::get_rounding_mode())
				{
				case FE_TONEAREST:
					// Round to nearest, ties to even
					if (round_bit && (lsb || (r != 0))) { ++y; }
					break;
				case FE_UPWARD:
					if (round_bit || (r != 0)) { ++y; }
					break;
				default: break;
				}

				return support::bit_cast<T>(y);
			}

			// This calculates the square root of any IEEE-754 floating point number using the shift and add algorithm.
			// The function accounts for all rounding modes and special cases.
			template <typename T>
			static constexpr std::enable_if_t<std::is_floating_point_v<T>, T> sqrt_impl(T x) // NOLINT
			{
				if constexpr (Is80BitLongDouble_v<T>) { return bit80::sqrt_calc_80bits(x); }
				else
				{
					// IEEE floating points formats.
					using FPBits_t		   = support::FPBits<T>;
					constexpr auto flt_nan = FPBits_t::quiet_nan().get_val();

					const FPBits_t bits(x);

					//bits.uin

					//lut_double_sqrt_first_256
					// Handle special cases where the bits are +Inf, ±0, or ±NaN
					if (CCM_UNLIKELY(bits == FPBits_t::inf(types::Sign::POS) || bits.is_zero() || bits.is_nan())) { return x; }

					// Handle special cases where the bits are -Inf or -num
					if (CCM_UNLIKELY(bits.is_neg())) { return -flt_nan; }

					// If we didn't encounter any special cases, we can calculate the square root normally.
					return sqrt_calc_bits(bits);
				}
			}
		} // namespace impl
	} // namespace internal

	template <typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
	constexpr T sqrt_ct(T num)
	{
		return internal::impl::sqrt_impl(num);
	}

} // namespace ccm::ct
